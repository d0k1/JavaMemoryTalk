<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>Java Memory</title>

        <meta name="description" content="Presentation about java memory model">
        <meta name="author" content="Denis V. Kirpichenkov">

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/white.css" id="theme">

        <link rel="stylesheet" href="css/hljs/vs.css" id="highlight-theme">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->

        <style>
.reveal .slide-number {
    font-size:22pt;
    color:black;
}

.reveal pre {
    background: none;
    border: none;
    box-shadow: none;    
}

.reveal pre code{
    color: black;
    background: none;
    box-shadow: none;
    max-height: none;
}

.reveal section img {
    border: none;
    box-shadow: none;
}

.reveal pre code {
    overflow: hidden;
}

.blinking-cursor {
  font-weight: 100;
  font-size: 30px;
  color: #2E3D48;
  width:10px;
  background-color:black;
  -webkit-animation: 1s blink step-end infinite;
  -moz-animation: 1s blink step-end infinite;
  -ms-animation: 1s blink step-end infinite;
  -o-animation: 1s blink step-end infinite;
  animation: 1s blink step-end infinite;
}

@keyframes "blink" {
  from, to {
    background-color:white;
    color: transparent;
  }
  50% {
    color: black;
    background-color:black;
  }
}

@-moz-keyframes blink {
  from, to {
    background-color:white;
    color: transparent;
  }
  50% {
    color: black;
    background-color:black;
  }
}

@-webkit-keyframes "blink" {
  from, to {
    background-color:white;
    color: transparent;
  }
  50% {
    color: black;
    background-color:black;
  }
}

@-ms-keyframes "blink" {
  from, to {
    background-color:white;
    color: transparent;
  }
  50% {
    color: black;
    background-color:black;
  }
}

@-o-keyframes "blink" {
  from, to {
    background-color:white;
    color: transparent;
  }
  50% {
    color: black;
    background-color:black;
  }
}
        </style>
    </head>

    <body>

        <div class="reveal">

            <!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">
                <section>
                    <h1>Java Memory: What Why Where How</h1>
                    <p>
                        <!--
                        <small>
                        <a href="http://focus-it.ru">Кирпиченков Денис</a> / <a href="http://twitter.com/dkirpichenkov">@dkirpichenkov</a>/ <a href="mailto:d0k1@mail.ru">d0k1@mail.ru</a>
                        <br/>
                        <br/>
                        <a href="https://d0k1.github.io/UnitTestingInRealLife/">d0k1.github.io/UnitTestingInRealLife/</a>
                        </small>
                        -->
                    </p>
                </section>

                <section>
                    <h1>План</h1>
                    <p>
                        <ul>
                            <li>Регионы памяти JVM</li>
                            <li>Виды сборок мусора</li>
                            <li>GC лог</li>
                            <li>JVM Arguments</li>
                            <li>32bit/64bit</li>
                            <li>OutOfMemoryError</li>
                            <li>Strong/Weak References</li>
                            <li>Metaspace</li>
                            <li>Native memory</li>                            
                            <li>GCEasy / GCViewer</li>
                            <li>VisualVM</li>
                            <li>Eclipse Memory Analyzer</li>
                        </ul>
                    </p>
                </section>
                
                <section>
                    <h1>Регионы памяти JVM</h1>
                    <img src="img/java_memory_regions.jpg"/>
                </section>

                <section>
                    <h1>Виды сборок мусора</h1>
                    <ul>
                        <li>Minor GC</li>
                        <li>FullGC</li>
                    </ul>
                    <img src="img/java_memory_regions.jpg"/>
                </section>

                <section>
                    <h1>GC лог</h1>
<pre style="width:auto; max-height:auto; font-size: 14pt;">
Java HotSpot(TM) 64-Bit Server VM (25.60-b23) for linux-amd64 JRE (1.8.0_60-b27)
Memory: 4k page, physical 4046656k(3469764k free), swap 131068k(131068k free)
CommandLine flags: -XX:InitialHeapSize=2684354560 -XX:+ManagementServer -XX:MaxHeapSize=2684354560 
-XX:MaxMetaspaceSize=402653184 -XX:+PrintGC -XX:+PrintGCDateStamps 
-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:ReservedCodeCacheSize=104857600 -XX:ThreadStackSize=512 
-XX:-TieredCompilation -XX:+UnlockCommercialFeatures -XX:+UseCompressedClassPointers 
-XX:+UseCompressedOops -XX:+UseParallelOldGC 

2017-03-31T06:37:04.396+0000: 15.909: [GC (Allocation Failure) 
[PSYoungGen: 764409K->109038K(551424K)] 
892078K->304714K(2299392K), 0.1895485 secs] 
[Times: user=0.22 sys=0.01, real=0.19 secs] 

2017-03-31T06:37:07.514+0000:19.027: [GC (Metadata GC Threshold) 
[PSYoungGen: 506766K->51971K(494592K)]
702442K->270793K(2242560K), 0.0514184 secs]
[Times: user=0.08 sys=0.01, real=0.05 secs] 

2017-03-31T06:37:07.565+0000:19.078: [Full GC (Metadata GC Threshold)
[PSYoungGen: 51971K->0K(494592K)]
[ParOldGen: 218821K->72091K(1747968K)]
270793K->72091K(2242560K), 
[Metaspace: 20842K->20842K(1069056K)], 0.1548107 secs] 
[Times: user=0.25 sys=0.01, real=0.16 secs] 
</pre>
                </section>

                <section>
                    <h1>JVM Arguments</h1>
                    <p>Настройка регионов памяти: Heap
<pre style="width:auto; max-height:auto;">
-Xmx1g -Xms100m
</pre>
                    </p>

                    <p>Настройка регионов памяти: Metaspace
<pre style="width:auto; max-height:auto;">
-XX:MaxMetaspaceSize256 -XX:MetaspaceSize=100M
</pre>
                    </p>
                    <p>Включение логирования сборки мусора
<pre style="width:auto; max-height:auto;">
-Xloggc:gc.log -XX:+PrintGCDetails
</pre>
                    </p>
                </section>

                <section>
                    <h1>32bit/64bit</h1>
<pre style="width:auto; max-height:auto;"><code>
// Dummy Entity representing usual data objects
    private static class Entity {
    public String name;
    public String detail;
    public Double amount;
    public Integer age;
    }
</code></pre>
                </section>

                <section>
                    <h1>32bit/64bit</h1>
<pre style="width:auto; max-height:auto; font-size: 12pt;"><code>
// Linked list offers table inserts and helps illustrating the issue by using multiple
// references per entry
public static java.util.LinkedList&lt;Entity&gt; entities = 
new java.util.LinkedList&lt;&gt;();

// This threshold ensures the loop stops before a full GC happens.
private static final int MB = 1024 * 1024;
private static final int THRESHOLD = 100 * MB;

public static void main(String[] args) {
    System.out.println("Total Memory (in bytes): " + Runtime.getRuntime().totalMemory());
    System.out.println("Free Memory (in bytes): " + Runtime.getRuntime().freeMemory());
    System.out.println("Max Memory (in bytes): " + Runtime.getRuntime().maxMemory());

    while (true) {
        appendEntitiesToDataStructure();
        terminateBeforeFullGCorOOMEcanHappen();
    }
}
</code></pre>
                </section>

                <section>
                    <h1>32bit/64bit</h1>
<pre style="width:auto; max-height:auto;">
    java -Xms31g -Xmx31g -Xmn50m Memory
    java -Xms32g -Xmx32g -Xmn50m Memory    
</pre>
                </section>

                <section>
                    <h1>32bit/64bit</h1>
<pre style="width:auto; max-height:auto;">
java -Xms31g -Xmx31g -Xmn50m Memory
Elements created and added to LinkedList: 587889429 
</pre>
<pre style="width:auto; max-height:auto;">
java -Xms32g -Xmx32g -Xmn50m Memory
Elements created and added to LinkedList: 385481085
</pre>
                </section>

                <section>
                    <h1>3 Shades of OutOfMemoryError</h1>
                    <ul>
                        <li>java.lang.OutOfMemoryError: Java heap space</li>
                        <li>java.lang.OutOfMemoryError: Metaspace</li>
                        <li>java.lang.OutOfMemoryError: GC overhead limit exceeded</li>
                    </ul>
                </section>

                <section>
                    <h1>Strong Reference</h1>
This is the default type/class of Reference Object, if not differently specified: builder is a strong Reference Object. This kind of reference makes the referenced object not eligible for GC. That is, whenever an object is referenced by a chain of strong Reference Objects, it cannot be garbage collected.
<pre style="width:auto; max-height:auto;"><code data-trim class="java">
StringBuilder builder = new StringBuilder();
</code></pre>
                </section>

                <section>
                    <h1>Weak Reference</h1>
                    Weak Reference Objects are not the default type/class of Reference Object and to be used they should be explicitly specified like in the above example. This kind of reference makes the reference object eligible for GC. That is, in case the only reference reachable for the StringBuilder object in memory is, actually, the weak reference, then the GC is allowed to garbage collect the StringBuilder object. When an object in memory is reachable only by Weak Reference Objects, it becomes automatically eligible for GC.
<pre style="width:auto; max-height:auto;"><code data-trim class="java">
WeakReference&lt;StringBuilder&gt; weakBuilder = 
    new WeakReference&lt;StringBuilder&gt;(builder);

//weakBuilder.get();
</code></pre>
                </section>

                <section>
                    <h1>Metaspace</h1>
                </section>

                <section>
                    <h1>Native memory</h1>
                </section>

                <section>
                    <h1>GCEasy</h1>
                </section>

                <section>
                    <h1>GCViewer</h1>
                </section>

                <section>
                    <h1>VisualVM</h1>
                </section>

                <section>
                    <h1>Eclipse Memory Analyzer</h1>
                </section>

                <!--
                <section>
<pre style="width:auto; max-height:auto;"><code data-trim class="java">
</code></pre>
                </section>
-->

                <section>
                    <h1>Практическая часть</h1>                                        
                    <ul>
                        <li>Twitter</li>
                        <li>JMeter</li>
                        <li>Eclipse Memory Analyzer</li>                        
                    </ul>
                </section>

                <section>
                    <h1>Практическая часть</h1>                                        
                    <ul>
                        <li>Запустить twitter выделив ему 256М</li>
                        <li>Создать нагрузку на приложение (JMeter)</li>
                        <li>Посмотреть на работу GC в VisualVM</li>
                    </ul>
                </section>

                <section>
                    <h1>Практическая часть</h1>                                        
                    <ul>
                        <li>Открыть heapdump</li>
                        <li>Указать видимые проблемы</li>
                    </ul>
                </section>

            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>

            // Full list of configuration options available at:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: false,
                progress: true,
                history: true,
                center: true,
                slideNumber: true,

                transition: 'slide', // none/fade/slide/convex/concave/zoom

                // Optional reveal.js plugins
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/zoom-js/zoom.js', async: true },
                    { src: 'plugin/notes/notes.js', async: true }
                ]
            });

        </script>

    </body>
</html>
